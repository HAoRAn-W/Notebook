# 垃圾回收算法

1. 标记清除：效率低，产生大量的内存碎片
2. 标记整理：需要整理的过程，但是无内存碎片
3. 复制：内存分为两块，每次只用一块。回收的时候把存活对象移动另一块。速度快，无内存碎片，但空间利用率低

# 判断对象存活的方法

1. 引用计数：无法回收循环引用的对象
2. 可达性分析：从 GC root 开始向下搜索。找到没有引用链可以达到的对象。GC root：Java 栈中引用的对象；方法区类静态属性引用的对象；方法区常量池引用的对象；本地方法栈 JNI 引用的对象

# 分代收集理论

建立在两个假设的基础上：

1. 弱分代：大部分对象的生命周期都很短暂
2. 强分代：多次 GC 都存活的对象越不容易被回收

基于这两个假设，收集器将对象分为不同的区域，对象根据年龄生活在不同区域。分代收集有一个明显的问题，就是“跨代引用”：老年代对象引用新生代对象。因此总结出第三个假设：跨代引用相比于同带引用占少数。

因此不需要扫描整个老年代，也不需要浪费空间专门记录那些新生代由对象是跨代引用。只需要在新生代建立一个全局的数据结构（记忆集），把老年代分为多个区域，表示哪一块存在跨代应用，之后 minor GC 时，只有这些有跨代引用的内存会被加入扫描。

- Minor GC：新生代收集
- Major GC：老年代收集
- Full GC：整堆收集
- Mixed GC：在 Z1 收集器中，收集整个新生代和部分老年代

# 算法实现细节

## GC roots 根节点的枚举

HotSpot 中采用了 OOP Map 的数据结构，OOP Map 中存储了到底哪里有对象的引用，在扫描的时候就可以直接从 OOP Map 中获取到哪些位置有引用，就不需要遍历所有的 GC Roots。OopMap 中存储了两种对象的引用：

1. 栈里和寄存器内的引用
2. 对象内的引用

## 安全点

对象之间的引用关系随时都会发生改变，这意味着对应的 OopMap 需要同步进行更新。如果每一条指令的执行，都生成（或更新）对应的 OopMap，那么将会占用大量的内存空间，增加了 GC 的空间成本。JVM 引入 Safe Point 的概念，只有在 Safe Point 才会生成（或更新）对应的 OopMap。

用户线程执行过程中的一些特殊位置，当前的状态是确定的，线程有哪些对象、使用了哪些内存。

哪些地方适合放置 Safe Point？

1. 所有的非计数循环的末尾（防止循环体的执行时间太长，一直进入不了 Safe Point）
2. 所有方法返回之前
3. 每条 Java 编译后的字节码的边界

Safe Point 的数量不能太少，太少会导致进入 Safe Point 的前置时间过长，以至于垃圾回收线程等待的时间太长。Safe Point 的数量也不能太多，太多意味着将会频繁生成（或更新）OopMap ，会有性能损耗。

让所有线程在 GC 时都到达 Safe Point，有两种方法中断线程：

1. 抢占式中断(Preemptive Suspension)：JVM 中断所有线程，然后依次检查每个线程中断的位置是否为 Safe Point，如果不是则恢复这个线程，让它执行至 Safe Point 再阻塞。
2. 主动式中断(Voluntary Suspension)：大部分 JVM 实现都是采用主动式中断，需要阻塞用户线程的时候，首先做一个标志，用户线程会主动轮询这个标志位，如果标志位处于就绪状态，就自行中断。

## 安全区域

如用户线程处于 Sleep 或者 Blocked 状态， 这时候线程就没办法响应虚拟机的中断请求，但是虚拟机也不能一直干等着用户线程执行，因此就引入了安全区域，安全区域能确保在某一段代码片段中，引用关系不会发生变化。因此在这个区域任何位置开始垃圾收集都是安全的。

# 并发的可达性分析

从 GC Roos 往下遍历对象的时间是随着堆内存的大小正比例增长的（堆内存越大，对象越多，对象之间的关系越复杂，那这个过程所花的时间就越长

## 三色标记

- 黑色为已经遍历过并且可达的对象，并且其直接引用的对象也已经遍历过
- 灰色为自身已经遍历过，但其直接引用的对象还未遍历完
- 白色为待遍历或者遍历过但仍不可达对象，但是这个对象上至少存在一个引用还没有被扫描过

## GC Roots 对象遍历一致性快照

# 常见垃圾回收器

## Serial

单线程，复制算法。回收过程必须停止用户线程（stop-the-world）

## ParNew

多线程，复制算法，stop-the-world（Serial 的多线程版本）

## Parallel Scavenger

多线程，复制算法，用于新生代，目标是达到可控的吞吐量

## Serial Old

单线程，标记整理，老年代，stop-the-world

## Parallel Old

多线程，标记整理， 老年代

## CMS

标记清除。以最短回收停顿时间为目标。

## G1

# CMS(Concurrent Mark Sweep)

并发，标记清除。以获取最短回收停顿时间为目标。

## 步骤

1. 初始标记：标记 GC roots 的下一级（仅下一级），STW。这个过程很快
2. 并发标记：根据上一步结果，多线程并发，向下标记所有的关联对象。无 STW
3. 重新标记：标记第二步过程中产生的垃圾
4. 并发清除：清理死亡对象

## 缺点

1. 并发导致资源紧张
2. 无法清理浮动垃圾：这一次无法清理的垃圾，只能留到下一次 GC 清除
3. 并发失败：内存不足，只能使用 Serial Old 对老年代回收
4. 内存碎片：需要在 Full GC 前对内存进行整理

# G1
