# 进程和线程的区别

- 进程是资源管理的基本单位。线程是 CPU 调度的基本单位
- 线程切换上下文并进程更快
- 进程内的线程共享资源，线程本身不拥有系统资源
- 创建和销毁进程需要的开销大于线程

# 协程和线程

- 线程是同步机制，协程是异步机制
- 线程是抢占式，协程是非抢占式。用户需要释放协程的使用权给其他协程。
- 协程不由操作系统内核管理，完全由程序控制
- 协程可以保留上一次调用时的状态

# 并发和并行

并发是宏观的多个程序同时运行，但是在任意时刻只有一个程序在执行

并行是同一时刻有多个程序运行，所以需要多核处理器才可以完成

# 进程和线程的切换

进程：

1. 切换页表以使用新的地址空间，上下文被切换后，CPU 缓存的内存地址就作废了
2. 切换内核栈和硬件上下文

线程：

只需要切换内核栈和硬件上下文。因为进程有自己的虚拟地址空间，线程共享这个地址空间，所以同一个进程中的线程切换不需要转换虚拟地址空间

## 虚拟地址空间的切换为什么耗时

进程有自己的虚拟地址空间，切换进程时，需要把虚拟地址转换为物理地址。此时需要查找页表，这个过程是很慢的。

因此可以用 Cache 来缓存常用的地址映射（TLB, transition lookaside buffer），加速页表查找

每个进程都有自己的页表，切换进程后页表也要切换，此时 TLB 就失效了。Cache 命中率低，导致虚拟地址到物理地址的转换变慢。

# 进程间通信方式

## 管道

### 匿名管道

父子进程间通信 pipe()

单向

内核对管道进行同步和互斥

进程退出，管道也就释放了

### 命名管道

适用于任意进程间通信，mkfifo()

单向

存在于文件系统中，不会随进程退出而消失

## 信号

可以在任一时刻发送给进程

常用信号：

1. SIGHUP: 用户从终端注销后，所有已经启动的进程都会收到，默认处理的终止进程
2. SIGINT: 程序终止信号，Ctrl+C
3. SIGKILL: 用户终止进程执行，kill -9 pid
4. SIGTERM: 结束进程，kill pid
5. SIGFPE: 运算出现致命错误，如除 0，数据溢出
6. SIGCLD: 子进程退出信号，如果父进程没有忽略或处理，子进程退出后会成为僵尸进程。

## 信号量 semaphore

一个计数器，用来控制多个进程对共享资源的访问。是一种锁机制。防止某进程正在访问共享资源的时候其他进程页访问该资源。

信号量会有初值（>0），每当有进程申请使用信号量，通过一个 P 操作来对信号量进行-1 操作，当计数器减到 0 的时候就说明没有资源了，其他进程要想访问就必须等待（具体怎么等还有说法，比如忙等待或者睡眠），当该进程执行完这段工作（我们称之为临界区）之后，就会执行 V 操作来对信号量进行+1 操作

当有进程要求使用共享资源时，需要执行以下操作：

1. 系统首先要检测该资源的信号量；

2. 若该资源的信号量值大于 0，则进程可以使用该资源，此时，进程将该资源的信号量值减 1；

3. 若该资源的信号量值为 0，则进程进入休眠状态，直到信号量值大于 0 时进程被唤醒，访问该资源；

当进程不再使用由一个信号量控制的共享资源时，

## 消息队列 TODO

消息的链接表，如 Posix 消息队列和 System V 消息队列。有足够权限的进程可以向队列添加消息，有读权限的进程可以读走消息。

独立于收发进程而存在，

## 共享内存

映射一段可以被其他进程访问的内存，速度快。需要处理同步的问题。

## socket

不同主机间的进程通信

# 进程同步的方式

## 临界区

串行化访问公共资源或代码。但只可以同步同一个进程内的线程，无法同步多个进程中的线程。

临界区解决冲突的办法：

- 一次只允许一个进程进入临界区，其他进程必须等待
- 临界区内的进程要在有限时间内退出
- 进程无法进入自己的临界区，应让出 CPU

## 互斥量

可命名，因此可以在不同进程间实现对资源的安全共享。只有拥有互斥兑现的线程才有访问资源的权限

## 信号量

控制一个有数量的用户资源。允许多个进程同时访问一个资源，但有最大访问的数目。

# 线程的分类

## 用户级线程

仅存在于用户级中，不依赖于操作系统核心，无法被操作系统感知，完全靠应用进程创建，管理

## 内核级线程

依赖于内核，创建，销毁，切换都由内核完成。

# 死锁

在多个并发的进程中，每个进程持有其他进程需要的资源，并等待其他进程释放持有的资源，从而导致各个进程都无法继续运行，这一现象就叫做死锁。

## 死锁产生的 4 个条件

- 互斥：一个资源只可被一个进程使用，无法共享
- 请求与保持：进程请求别的资源时，已有的资源不释放
- 不剥夺：进程获得的资源在没有使用完之前，无法被剥夺
- 循环等待：若干进程形成头尾相接的环形等待资源的关系

四个条件缺一不可。

## 死锁的预防

- 资源共享
- 预分配：进程运行之前必须完全获得全部所需资源。（缺点：降低进程的并发性和资源利用率；很多情况下所需要的资源是动态的，无法预先知道）
- 允许抢占资源
- 资源有序分配，按照顺序获取资源，稀少资源必须在丰富的资源之后申请

## 死锁的避免

允许前三个条件，并动态监测资源的分配状态，确保不出现循环等待：如果系统可以按照某个顺序为每个进程分配资源（不超过最大值），就是安全的。如银行家算法：

1. Available 向量：系统中可利用的资源数目
2. Max 矩阵：每个进程对每种资源的最大需求
3. Allocation 矩阵：每个进程已分配的各类资源的数目
4. Need 矩阵：每个进程还需要的各类资源数

- 要判断是否为安全状态，首先先找出它的 Need: Need[i,j] = Max[i,j] - allocation[i, j]

- 接下来找出 need 比 available 小的，把资源配置给它，再回收（Available + Allocation）
- 标记这个 process 为已完成，以此类推
- 如果所有 Process 都可以完成并终止，则一个状态被认为是安全的。由于系统无法知道什么时候一个过程将终止，或者之后它需要多少资源，系统假定所有进程将最终试图获取其声明的最大资源并在不久之后终止。在大多数情况下，这是一个合理的假设，因为系统不是特别关注每个进程运行了多久（至少不是从避免死锁的角度）。此外，如果一个进程终止前没有获取其能获取的最多的资源，它只是让系统更容易处理。

基于这一假设，该算法通过尝试寻找允许每个进程获得的最大资源并结束（把资源返还给系统）的进程请求的一个理想集合，来决定一个状态是否是安全的。不存在这个集合的状态都是不安全的。

## 死锁检测

死锁检测不限制资源的访问或者约束进程的行为，但是操作系统会周期的执行算法检查循环等待的条件：

- 进程-资源分布图中无环：没有死锁
- 进程-资源分布图中有环，且每个资源类只有一个资源：死锁
- 进程-资源分布图中有环，但是涉及的资源类有多个资源，不一定会发生死锁

## 死锁解除

终止进程：终止一个或者多个进程直到打破循环等待

资源抢占：从一个或多个死锁进程中抢占资源

## 鸵鸟策略

当发生死锁的概率很低，或者不会对用户造成太大影响，那么就直接忽略它。

# 进程调度策略

## 先来先服务

非抢占式，按照顺序执行任务。有利于长任务，不利于短任务。

## 短作业优先

非抢占式，按估计运行时间调度，不利于长任务，可能会饿死，因为一直等待短作业执行完毕，如果一直有短作业进来，就永远得不到调度

## 最短剩余时间优先

抢占式的短作业优先。按剩余运行时间调度，新的任务到达，如果比当前执行任务的剩余时间要少，则挂起当前任务，运行新的任务

## 时间片轮转

按 FCFS 原则排成一个队列，把 CPU 时间片轮番分配给各个进程，时间片用完，调度程序就停止该进程的执行。时间片过短，会造成进程的频繁切换，影响效率，时间片过长，就会无法保证实时性

## 优先级调度

按照优先级调度，为了防止优先级低的进程永远得不到调度，可以随时间推移增加等待进程的优先级

# 进程的状态

## 创建

## 就绪

处于准备运行的状态，已经获得了除 CPU 以外的所需资源

## 运行

进程正在 CPU 上运行

## 阻塞

进程在等待某一事件而暂停运行，如等待资源可用或者等待 IO 完成。

## 终止

# 分页

把内存划分为大小相等且固定的块，作为主存的基本单位。程序的数据分布在不同的页中，不同的页分散在内存中，所以需要页表来记录映射关系，实现从页号到物理块号的映射。

访问分页系统的内存数据需要两次内存访问，一次是访问页表，获得对应的物理块号，再加上页内偏移，得到实际的物理地址；一次是用得到的物理地址访问内存得到数据

# 分段

分页提高了内存的利用率，而分段满足了编写代码时的逻辑需求，如数据共享，数据保护，动态链接

分段内存管理中，地址是二维的，一维是段号，二维是段内地址。每个段的长度不同，段内从 0 开始编址。分段管理中，每个段内部的内存是连续分配的。

段和段之间是离散的，因此用段表机制映射逻辑到物理地址的关系。

# 分页和分段的区别

- 分页对程序员透明，分段需要程序员显示的划分
- 分页的地址空间是一维的，分段的地址空间是二维的
- 页的大小不变，段的大小可以动态改变
- 分页为了实现虚拟内存，从而获得更大的地址空间；分段是为了使程序和数据可被划分为逻辑上独立的地址空间，有助于数据保护和共享。

# 交换空间

当内存不足时，Linux 把一些页从内存转移到硬盘，以释放内存空间。磁盘上的那一块空间就叫做交换空间。这么做可以再内存不足的时候把一些不常用的页交换出去，腾给系统

# 物理地址，逻辑地址，有效地址，线性地址，虚拟地址（TODO）

# 页面替换算法

程序运行时，如果要访问的页不在内存中，就会发生缺页中断，从而将该页调入内存中。当内存无空闲空间时，需要选择一个页面替换到磁盘对换区来腾出空间。

## 最优算法

不可实现，但作为算法衡量的基准

## NRU 最近未访问

两个标志位：R(页面被访问)，M(页面被修改)。根据这两个标志位，把页分为 4 类：

1. 0 类：没访问没修改
2. 1 类：没访问，修改了
3. 2 类：访问，没修改
4. 3 类：访问，修改

启动一个进程时，M 和 R 都为 0，R 会被定期的清零（比如每次时钟中断）。编号越小，越被优先换出。随机淘汰一个编号最小的页。

## FIFO 先进先出
