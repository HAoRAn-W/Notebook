# 进程和线程的区别

- 进程是资源管理的基本单位。线程是 CPU 调度的基本单位
- 线程切换上下文并进程更快
- 进程内的线程共享资源，线程本身不拥有系统资源
- 创建和销毁进程需要的开销大于线程

# 协程和线程

- 线程是同步机制，协程是异步机制
- 线程是抢占式，协程是非抢占式。用户需要释放协程的使用权给其他协程。
- 协程不由操作系统内核管理，完全由程序控制
- 协程可以保留上一次调用时的状态

# 并发和并行

并发是宏观的多个程序同时运行，但是在任意时刻只有一个程序在执行

并行是同一时刻有多个程序运行，所以需要多核处理器才可以完成

# 进程和线程的切换

进程：

1. 切换页表以使用新的地址空间，上下文被切换后，CPU 缓存的内存地址就作废了
2. 切换内核栈和硬件上下文

线程：

只需要切换内核栈和硬件上下文。因为进程有自己的虚拟地址空间，线程共享这个地址空间，所以同一个进程中的线程切换不需要转换虚拟地址空间

## 虚拟地址空间的切换为什么耗时

进程有自己的虚拟地址空间，切换进程时，需要把虚拟地址转换为物理地址。此时需要查找页表，这个过程是很慢的。

因此可以用 Cache 来缓存常用的地址映射（TLB, transition lookaside buffer），加速页表查找

每个进程都有自己的页表，切换进程后页表也要切换，此时 TLB 就失效了。Cache 命中率低，导致虚拟地址到物理地址的转换变慢。

# 进程间通信方式

## 管道

### 匿名管道

父子进程间通信 pipe()

单向

内核对管道进行同步和互斥

进程退出，管道也就释放了

### 命名管道

适用于任意进程间通信，mkfifo()

单向

存在于文件系统中，不会随进程退出而消失

## 信号

可以在任一时刻发送给进程

常用信号：

1. SIGHUP: 用户从终端注销后，所有已经启动的进程都会收到，默认处理的终止进程
2. SIGINT: 程序终止信号，Ctrl+C
3. SIGKILL: 用户终止进程执行，kill -9 pid
4. SIGTERM: 结束进程，kill pid
5. SIGFPE: 运算出现致命错误，如除 0，数据溢出
6. SIGCLD: 子进程退出信号，如果父进程没有忽略或处理，子进程退出后会成为僵尸进程。

## 信号量 semaphore

一个计数器，用来控制多个进程对共享资源的访问。是一种锁机制。防止某进程正在访问共享资源的时候其他进程页访问该资源。

信号量会有初值（>0），每当有进程申请使用信号量，通过一个 P 操作来对信号量进行-1 操作，当计数器减到 0 的时候就说明没有资源了，其他进程要想访问就必须等待（具体怎么等还有说法，比如忙等待或者睡眠），当该进程执行完这段工作（我们称之为临界区）之后，就会执行 V 操作来对信号量进行+1 操作

当有进程要求使用共享资源时，需要执行以下操作：

1. 系统首先要检测该资源的信号量；

2. 若该资源的信号量值大于 0，则进程可以使用该资源，此时，进程将该资源的信号量值减 1；

3. 若该资源的信号量值为 0，则进程进入休眠状态，直到信号量值大于 0 时进程被唤醒，访问该资源；

当进程不再使用由一个信号量控制的共享资源时，

## 消息队列 TODO

消息的链接表，如 Posix 消息队列和 System V 消息队列。有足够权限的进程可以向队列添加消息，有读权限的进程可以读走消息。

独立于收发进程而存在，

## 共享内存

映射一段可以被其他进程访问的内存，速度快。需要处理同步的问题。

## socket

不同主机间的进程通信

# 进程同步的方式

## 临界区

串行化访问公共资源或代码。但只可以同步同一个进程内的线程，无法同步多个进程中的线程。

临界区解决冲突的办法：

- 一次只允许一个进程进入临界区，其他进程必须等待
- 临界区内的进程要在有限时间内退出
- 进程无法进入自己的临界区，应让出 CPU

## 互斥量

可命名，因此可以在不同进程间实现对资源的安全共享。只有拥有互斥兑现的线程才有访问资源的权限

## 信号量

控制一个有数量的用户资源。允许多个进程同时访问一个资源，但有最大访问的数目。

# 线程的分类

## 用户级线程

仅存在于用户级中，不依赖于操作系统核心，无法被操作系统感知，完全靠应用进程创建，管理

## 内核级线程

依赖于内核，创建，销毁，切换都由内核完成。

# 死锁

在多个并发的进程中，每个进程持有其他进程需要的资源，并等待其他进程释放持有的资源，从而导致各个进程都无法继续运行，这一现象就叫做死锁。

## 死锁产生的 4 个条件

- 互斥：一个资源只可被一个进程使用，无法共享
- 请求与保持：进程请求别的资源时，已有的资源不释放
- 不剥夺：进程获得的资源在没有使用完之前，无法被剥夺
- 循环等待：若干进程形成头尾相接的环形等待资源的关系

四个条件缺一不可。

## 死锁的预防

- 资源共享
- 预分配：进程运行之前必须完全获得全部所需资源。（缺点：降低进程的并发性和资源利用率；很多情况下所需要的资源是动态的，无法预先知道）
- 允许抢占资源
- 资源有序分配，按照顺序获取资源，稀少资源必须在丰富的资源之后申请

## 死锁的避免

允许前三个条件，并动态监测资源的分配状态，确保不出现循环等待：如果系统可以按照某个顺序为每个进程分配资源（不超过最大值），就是安全的。如银行家算法：

1. Available 向量：系统中可利用的资源数目
2. Max 矩阵：每个进程对每种资源的最大需求
3. Allocation 矩阵：每个进程已分配的各类资源的数目
4. Need 矩阵：每个进程还需要的各类资源数

- 要判断是否为安全状态，首先先找出它的 Need: Need[i,j] = Max[i,j] - allocation[i, j]

- 接下来找出 need 比 available 小的，把资源配置给它，再回收（Available + Allocation）
- 标记这个 process 为已完成，以此类推
- 如果所有 Process 都可以完成并终止，则一个状态被认为是安全的。由于系统无法知道什么时候一个过程将终止，或者之后它需要多少资源，系统假定所有进程将最终试图获取其声明的最大资源并在不久之后终止。在大多数情况下，这是一个合理的假设，因为系统不是特别关注每个进程运行了多久（至少不是从避免死锁的角度）。此外，如果一个进程终止前没有获取其能获取的最多的资源，它只是让系统更容易处理。

基于这一假设，该算法通过尝试寻找允许每个进程获得的最大资源并结束（把资源返还给系统）的进程请求的一个理想集合，来决定一个状态是否是安全的。不存在这个集合的状态都是不安全的。

## 死锁检测

死锁检测不限制资源的访问或者约束进程的行为，但是操作系统会周期的执行算法检查循环等待的条件：

- 进程-资源分布图中无环：没有死锁
- 进程-资源分布图中有环，且每个资源类只有一个资源：死锁
- 进程-资源分布图中有环，但是涉及的资源类有多个资源，不一定会发生死锁

## 死锁解除

终止进程：终止一个或者多个进程直到打破循环等待

资源抢占：从一个或多个死锁进程中抢占资源

## 鸵鸟策略

当发生死锁的概率很低，或者不会对用户造成太大影响，那么就直接忽略它。

# 进程调度策略

## 先来先服务

非抢占式，按照顺序执行任务。有利于长任务，不利于短任务。

## 短作业优先

非抢占式，按估计运行时间调度，不利于长任务，可能会饿死，因为一直等待短作业执行完毕，如果一直有短作业进来，就永远得不到调度

## 最短剩余时间优先

抢占式的短作业优先。按剩余运行时间调度，新的任务到达，如果比当前执行任务的剩余时间要少，则挂起当前任务，运行新的任务

## 时间片轮转

按 FCFS 原则排成一个队列，把 CPU 时间片轮番分配给各个进程，时间片用完，调度程序就停止该进程的执行。时间片过短，会造成进程的频繁切换，影响效率，时间片过长，就会无法保证实时性

## 优先级调度

按照优先级调度，为了防止优先级低的进程永远得不到调度，可以随时间推移增加等待进程的优先级

# 进程的状态

## 创建

## 就绪

处于准备运行的状态，已经获得了除 CPU 以外的所需资源

## 运行

进程正在 CPU 上运行

## 阻塞

进程在等待某一事件而暂停运行，如等待资源可用或者等待 IO 完成。

## 终止

# 分页

把内存划分为大小相等且固定的块，作为主存的基本单位。程序的数据分布在不同的页中，不同的页分散在内存中，所以需要页表来记录映射关系，实现从页号到物理块号的映射。

访问分页系统的内存数据需要两次内存访问，一次是访问页表，获得对应的物理块号，再加上页内偏移，得到实际的物理地址；一次是用得到的物理地址访问内存得到数据

# 分段

分页提高了内存的利用率，而分段满足了编写代码时的逻辑需求，如数据共享，数据保护，动态链接

分段内存管理中，地址是二维的，一维是段号，二维是段内地址。每个段的长度不同，段内从 0 开始编址。分段管理中，每个段内部的内存是连续分配的。

段和段之间是离散的，因此用段表机制映射逻辑到物理地址的关系。

# 分页和分段的区别

- 分页对程序员透明，分段需要程序员显示的划分
- 分页的地址空间是一维的，分段的地址空间是二维的
- 页的大小不变，段的大小可以动态改变
- 分页为了实现虚拟内存，从而获得更大的地址空间；分段是为了使程序和数据可被划分为逻辑上独立的地址空间，有助于数据保护和共享。

# 交换空间

当内存不足时，Linux 把一些页从内存转移到硬盘，以释放内存空间。磁盘上的那一块空间就叫做交换空间。这么做可以再内存不足的时候把一些不常用的页交换出去，腾给系统

# 物理地址，逻辑地址，有效地址，线性地址，虚拟地址（TODO）

# 页面替换算法

程序运行时，如果要访问的页不在内存中，就会发生缺页中断，从而将该页调入内存中。当内存无空闲空间时，需要选择一个页面替换到磁盘对换区来腾出空间。

## 最优算法

不可实现，但作为算法衡量的基准

## NRU 最近未使用

两个标志位：R(页面被访问)，M(页面被修改)。根据这两个标志位，把页分为 4 类：

1. 0 类：没访问没修改
2. 1 类：没访问，修改了
3. 2 类：访问，没修改
4. 3 类：访问，修改

启动一个进程时，M 和 R 都为 0，R 会被定期的清零（比如每次时钟中断）。编号越小，越被优先换出。随机淘汰一个编号最小的页。

## FIFO 先进先出

链表结构，每次缺页中断把链表头部最老的页交换到磁盘，把新的页面加入到链表尾部。这种算法没有考虑到页的使用频率。

改进：二次机会算法。每个页面增加 R 位，每次从链表同步开始，R 为 1 则清除 R 位并置于尾部，如果遇到 R 为 0 的，就替换掉。

# clock 时钟算法

环形链表结构的第二次机会算法。指针指向最老的页面，缺页中断的时候执行相同的操作（检查 R 位，替换或置于尾部）。这样可以省去每次移动到链表尾部的操作。

改进：如果被淘汰的页面没有被修改过，就不需要执行 I/O 操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免 I/O 操作

# LRU 最近最少使用

置换未使用时间最长的页。维护一个链表，根据使用情况更新。

需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。困难的是在每次访问内存时都必须要更新整个链表。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常费时的操作，即使使用硬件实现也一样费时(假设有这样的硬件)。

## NFU 最不常用算法

有非常少的计算机拥有实现 LFU 的硬件。因此，需要一个能用软件实现的解决方案。

每次时钟中断时，由操作系统扫描内存中所有的页面，将每个页面的 R 位(它的值是 0 或 1)加到它的计数器上。这个计数器大体上跟踪了各个页面被访问的频繁程度。发生缺页中断时，则置换计数器值最小的页面

### 老化

只需对 NFU 做一个小小的修改就能使它很好地模拟 LRU。其修改分为两部分: 首先，在 R 位被加进之前先将计数器右移一位; 其次，将 R 位加到计数器最左端的位。这样增加了最近使用的比重

# 工作集算法

一个进程当前正在使用的页面的集合称为它的工作集。在任一时刻 t, 都存在一个集合，它包含所有最近 k 次内存访问所访问过的页面。这个集合 w(k, t)就是工作集。

当发生缺页中断时，淘汰一个不在工作集中的页面。确定一个长度为 k 的窗口作为工作集的大小。另外一种常见的近似方法就是，不是找最近 k 次的内存访问，而是考虑其执行时间：工作集即是过去 10ms 中的内存访问所用到的页面的集合。实际上，这样的模型很合适且更容易实现。

- 每个表项至少包含两条信息: 上次使用该页面的近似时间，R(访问)位。
- 假定使用硬件来置 R 位和 M 位。同样，假定在每个时钟滴答中，有一个定期的时钟中断会用软件方法来清除 R 位。
- 每当缺页中断发生时，扫描页表以找出一个合适的页面淘汰之。在处理每个表项时，都需要检查 R 位。如果它是 1,就把当前实际时间写进页表项的“上次使用时间”域，以表示缺页中断发生时该页面正在被使用。既然该页面在当前时钟滴答中已经被访问过，那么很明显它应该出现在工作集中，并且不应该被删除(假定 r 横跨多个时钟滴答)。
- 如果 R 是 0，那么表示在当前时钟滴答中，该页面还没有被访问过，则它就可以作为候选者被置换。为了知道它是否应该被置换，需要计算它的生存时间(即当前实际运行时间减去上次使用时间)，然后与做比较。如果它的生存时间大于 t，那么这个页面就不再在工作集中，而用新的页面置换它。扫描会继续进行以更新剩余的表项。
- 如果扫描完整个页表却没有找到适合被淘汰的页面，也就意味着所有的页面都在工作集中。在这种情况下，如果找到了一个或者多个 R= 0 的页面，就淘汰生存时间最长的页面。在最坏情况下，在当前时间滴答中，所有的页面都是 R=1，因此就随机选择一个页面淘汰，如果有的话最好选一个干净页面。

## 工作集时钟算法

环形链表数据结构，每次缺页中断时，首先检查指针指向的页面。如果 R 位被置为 1, 该页面在当前时钟滴答中就被使用过，那么该页面就不适合被淘汰。然后把该页面的 R 位置为 0，指针指向下一个页面，并重复该操作。

指针指向的页面在 R=0 时，如果页面的生存时间大于 t:

- 该页面是干净的 M=0，它就不在工作集中，并且在磁盘上有一个有效的副本。申请此页框，并把新页面放在其中
- 此页面被修改过 M=1，就不能立即申请页框，因为这个页面在磁盘上没有有效的副本。为了避免由于调度写磁盘操作引起的进程切换，指针继续向前走，算法继续对下一个页面进行操作。毕竟，有可能存在一个旧的且干净的页面可以立即使用。

原则上，所有的页面都有可能因为磁盘 I/O 在某个时钟周期被调度。为了降低磁盘阻塞，需要设置一个限制，即最大只允许写回 n 个页面。一旦达到该限制，就不允许调度新的写操作。

工作集时钟算法和老化算法有良好的性能，且可以被有效的实现。

# 虚拟内存

把物理内存扩充成更大的逻辑内存。让程序获得更多的可用内存。内存实际包含了磁盘。使用部分加载的技术，让一个进程的某一部分页面加载进内存，甚至可以加载比内存大的进程。

## 虚拟内存的实现方式

1. 请求分页存储管理
2. 请求分段存储管理
3. 请求段页式存储管理

# 硬链接和软链接

- 硬链接：在目录下创建一个条目，记录着文件名，`inode`编号。`inode`是源文件的`inode`。删除一个条目，源文件还存在（只要引用数量不为 0）。硬链接不可以跨越文件系统，也不可以对目录进行链接
- 软连接：又叫符号链接。保存着源文件的绝对路径，源文件被删除，符号链接也就打不开了。可以为目录建立符号链接。

# 中断处理过程

1. 保护现场：将当前执行程序的相关数据保存在寄存器中，然后入栈
2. 开中断：以便执行中断的时候可以响应高级别的中断请求
3. 中断处理
4. 关中断：保证恢复现场的时候不被新的中断干扰
5. 恢复现场：从堆栈中按顺序取出数据。恢复之前的执行状态

# 用户态和内核态

是操作系统的两种运行状态

## 用户态

程序受限制地访问内存，只能直接读取用户程序的数据。不允许访问外围设备， CPU 不允许独占。

## 内核态

可以不受限制地访问计算机的任意数据和资源。包块外围设备包括网卡硬盘等。处于内核态的 CPU 可以从一个程序切换到另一个程序，占用 CPU 不会发生抢占现象。
